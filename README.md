# WB_L1


1. ## Какой самый эффективный способ конкатенации строк?

strings.Builder потому что у него есть буфер в который он кладет строки и не выделяет заново память каждый раз

2. ## Что такое интерфейсы, как они применяются в Go?

Интерфейсы это набор сигнатур методов которые должна реализовывать структура которая хочет соответствовать этому интерфейсу. 
Также пустые интерфейсы соответствуют любому типу данных и могут служить для обработки всех типов данных

3. ## Чем отличаются RWMutex от Mutex?

Mutex полностью блокирует все горутины(кроме той в которой происходит блокировка)
которые пытаются записать или считать общие для них данные.

RWMutex не блокирует горутинам доступ к данным для чтения, однако блокирует на запись.


4. ## Чем отличаются буферизированные и не буферизированные каналы?

Не буферизированные каналы блокируют отправителя или получателя сразу после их действия с каналом. 
А буферизированные будут  блокировать горутины только после того как полностью заполнится выделенный буфер

5. ## Какой размер у структуры struct{}{}?
0 байт

6. ## Есть ли в Go перегрузка методов или операторов?

Go не поддерживает перегрузку методов и операторов. Это упрощает чтение и написание кода.

7. ## В какой последовательности будут выведены элементы map[int]int?

Рандомно, но функции fmt.Print для упрощения всегда выводят map в одном порядке. 
А если выводить map в цикле, то порядок не гарантируется

8. ## В чем разница make и new?

Make используется только для создания slice, map, chan.
New используется для любых структур.
Make возвращает экземпляр создаваемого типа, 
New возвращает указатель на создаваемый тип. 
Make выделяет место в памяти и инициализирует внутреннюю структуру данных, подготавливая значение для использования.
New выделяет место в памяти, но не инициализирует внутреннюю структуру данных.


9. ## Сколько существует способов задать переменную типа slice или map?

С помощью литералов, make, var

10. ## Что выведет данная программа и почему?

```go
func update(p *int) {
    b := 2
    p = &b
}

func main() {
    var (
        a = 1
        p = &a
    )
    fmt.Println(*p)
    update(p)
    fmt.Println(*p)
}
```


Функция update пытается изменить значение указателя, а не переменной на которую он указывает
Выведет сначал 1, затем 1. Потому что указатель p передается как копия. Чтобы изменить значение на которое указывает указатель
следует использовать *p = b

11. ## Что выведет данная программа и почему?

```go
func main() {
  wg := sync.WaitGroup{}
  for i := 0; i < 5; i++ {
     wg.Add(1)
     go func(wg sync.WaitGroup, i int) {
        fmt.Println(i)
        wg.Done()
     }(wg, i)
  }
  wg.Wait()
  fmt.Println("exit")
}
```

Данная программа выведет числа в произвольном порядке, затем произойдет deadlock из-за неправильной передачи WaitGroup в функцию
После выполнения все горутины заснут, а счетчик wg не достигнет нуля потому что в функцию передается его копия и функция wg.Done() ни на что не влияет

12. ## Что выведет данная программа и почему?

```go
func main() {
  n := 0
  if true {
     n := 1
     n++
  }
  fmt.Println(n)
}
```

Внутри другой области внутри условия создается другая переменная n и все что с ней происходит не влияет на n которая равна 0
Выведет 0

13. ## Что выведет данная программа и почему?

```go
func someAction(v []int8, b int8) {
  v[0] = 100
  v = append(v, b)
}

func main() {
  var a = []int8{1, 2, 3, 4, 5}
  someAction(a, 6)
  fmt.Println(a)
}
```


Выведет 100, 2, 3, 4 ,5. Слайс тоже передается как копия структуры, внутри которой лежит указатель на область в памяти
Когда происходит изменение внутри слайса, это работает потому что копия указателя указывает на ту же область в памяти.
Но когда происходит append под капотом память выделяется заново и значения переносятся в другое место, поэтому это никак
не отразится на слайсе который в main


14. ## Что выведет данная программа и почему?

```go
func main() {
  slice := []string{"a", "a"}

  func(slice []string) {
     slice = append(slice, "a")
     slice[0] = "b"
     slice[1] = "b"
     fmt.Print(slice)
  }(slice)
  fmt.Print(slice)
}
```


Выведется внутри функции b, b, a\
в main выведется a, a\
После append область в памяти сменилась и все изменения не влияют на первоначальный слайс


